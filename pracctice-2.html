<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //执行上下文与作用域
    //作用域链
    var color = "blue";
    function changecolor(){
        if(color==="blue"){
            color = 'red';
        }else{
            color="blue";
        }
    }
    changecolor();
    //changecolor包含2个对象，一个是arguments,一个是color（全局上下文对象），通过作用域链能够访问到color。
    var colora ="blue";
    function changecolora(){
        let an = "red";
        function sw(){
            let te = an;
            an = color;
            color = te;
            //一个局部上下文
        }
        sw();//不能访问到te，因为他出去了
    }
    changecolora();//只能访问到colora,因为他在最外面，只能访问到最外面。
    //作用域增强
    function bulid(){
        let qs = "debug=true";
        
        with(location){
            let url = href + qs;
            
        }
        
        return url;
        
    }
    function suma(num1,num2){
     var sum = num1+num2;
      sum = num1+num2;//删除var之后，外部的console.log（sum）就可以访问到。
        return sum;
    }
    var re = suma(10,20);//30
    console.log(re)
    //console.log(sum)sum不是一个有效的变量，sum定义在函数内部。
   //sum没有用var声明，被调用之后，sum就被添加到了全局上下文。

   //变量提升
   //console.log(qwe)//undefined
   var qwe=1
   //因为console.log(qwe)在var qwe=1上面声名了，所以找不到变量，就会输出undefined。

   //let与var的区别
   {
    var thinke
   }
   //console.log(thinke)//undefined
   {
       let th
   }
   //console.log(th)//报错
   //let是块级作用域，所以console.log(th)无法访问到。

   var as;
   var as;
   {
       let ab;
       //let ab;//报错，无法重复声明。
   }

   for (i=0;i<10;i++){

   }
   console.log(i)//迭代变量时会出现泄露。
   for(let j=0; j<10;j++ ){

   }
//cosnole.log(j)//无法访问到里面的作用域。

//const关键字
//const a;//没有初始化变量，会报错
const t = 3;
console.log(t)

if(true){
    const g = 0;
}
//console.log(g)//无法访问

const o1 = {};
//o1 = {};//const无法重新赋值
const o2 = {};
o2.name = "a";//可以应用到对象当中
console.log(o2.name);
 </script>
